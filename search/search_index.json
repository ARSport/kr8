{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kr8 kr8 is a configuration management tool for Kubernetes clusters, designed to generate deployable manifests for the components required to make your clusters usable. Its main function is to manipulate JSON and YAML without using a templating engine. It does this using jsonnet","title":"Home"},{"location":"#kr8","text":"kr8 is a configuration management tool for Kubernetes clusters, designed to generate deployable manifests for the components required to make your clusters usable. Its main function is to manipulate JSON and YAML without using a templating engine. It does this using jsonnet","title":"kr8"},{"location":"components/helm/","text":"Helm","title":"Helm"},{"location":"components/helm/#helm","text":"","title":"Helm"},{"location":"components/jk/","text":"jk","title":"Jk"},{"location":"components/jk/#jk","text":"","title":"jk"},{"location":"components/jsonnet/","text":"Jsonnet Component A very simple component might just be a few lines of jsonnet. Consider the situation whereby you might have two clusters, one in AWS and one in DigitalOcean. You need to set a default storageclass. You could do this with jsonnet. Your jsonnet component would look like this: components/storageclasses \u251c\u2500\u2500 Taskfile.yml \u251c\u2500\u2500 params.jsonnet \u251c\u2500\u2500 storageclasses.jsonnet Taskfile The taskfile for a component like would look like this: version: 2 tasks: fetch: desc: fetch component dependencies generate: desc: generate cmds: - kr8-helpers clean-output - kr8-helpers jsonnet-render storageclasses.jsonnet Notice we still add a fetch task which is an empty command Params As a reminder, every component requires a params file. We need to set a namespace for the component, even though it's a cluster level resource - namespace is a required paramater for kr8 { namespace: 'kube-system', release_name: 'storageclasses', } Jsonnet Manifest Your jsonnet manifest looks like this: local config = std.extVar('kr8'); # imports the config from params.jsonnet local kr8_cluster = std.extVar('kr8_cluster'); # a jsonnet external variable from kr8 that gets cluster values and data # a jsonnet function for creating a storageclass local StorageClass(name, type, default=false) = { apiVersion: 'storage.k8s.io/v1', kind: 'StorageClass', metadata: { name: name, annotations: { 'storageclass.kubernetes.io/is-default-class': if default then 'true' else 'false', }, }, parameters: { type: type, }, }; # check the cluster configuration for a type, if it's AWS make a gp2 type storageclass if kr8_cluster.cluster_type == 'aws' then kube.objectValues( { // default gp2 storage class, not tied to a zone ebs_gp2: StorageClass('gp2', 'gp2', true) {}, } ) else [] # don't make a storageclass if it's not AWS","title":"Jsonnet"},{"location":"components/jsonnet/#jsonnet-component","text":"A very simple component might just be a few lines of jsonnet. Consider the situation whereby you might have two clusters, one in AWS and one in DigitalOcean. You need to set a default storageclass. You could do this with jsonnet. Your jsonnet component would look like this: components/storageclasses \u251c\u2500\u2500 Taskfile.yml \u251c\u2500\u2500 params.jsonnet \u251c\u2500\u2500 storageclasses.jsonnet","title":"Jsonnet Component"},{"location":"components/jsonnet/#taskfile","text":"The taskfile for a component like would look like this: version: 2 tasks: fetch: desc: fetch component dependencies generate: desc: generate cmds: - kr8-helpers clean-output - kr8-helpers jsonnet-render storageclasses.jsonnet Notice we still add a fetch task which is an empty command","title":"Taskfile"},{"location":"components/jsonnet/#params","text":"As a reminder, every component requires a params file. We need to set a namespace for the component, even though it's a cluster level resource - namespace is a required paramater for kr8 { namespace: 'kube-system', release_name: 'storageclasses', }","title":"Params"},{"location":"components/jsonnet/#jsonnet-manifest","text":"Your jsonnet manifest looks like this: local config = std.extVar('kr8'); # imports the config from params.jsonnet local kr8_cluster = std.extVar('kr8_cluster'); # a jsonnet external variable from kr8 that gets cluster values and data # a jsonnet function for creating a storageclass local StorageClass(name, type, default=false) = { apiVersion: 'storage.k8s.io/v1', kind: 'StorageClass', metadata: { name: name, annotations: { 'storageclass.kubernetes.io/is-default-class': if default then 'true' else 'false', }, }, parameters: { type: type, }, }; # check the cluster configuration for a type, if it's AWS make a gp2 type storageclass if kr8_cluster.cluster_type == 'aws' then kube.objectValues( { // default gp2 storage class, not tied to a zone ebs_gp2: StorageClass('gp2', 'gp2', true) {}, } ) else [] # don't make a storageclass if it's not AWS","title":"Jsonnet Manifest"},{"location":"components/yaml/","text":"YAML Component kr8 can use a static k8s manifest as a source input. You can then manipulate the structure of that YAML using Jsonnet. kr8 takes care of the heavy lifting for you. Taskfile You'll need a taskfile that downloads the original manifests for you in the fetch task. Here's an example: version: 2 # Download the example manifests for the metrics server. # This creates a directory, vendored which contains the manifests tasks: fetch: desc: fetch component dependencies cmds: - rm -rf vendored - mkdir -p vendored sources - git clone --depth=1 https://github.com/kubernetes-incubator/metrics-server sources/metrics-server - cp -a sources/metrics-server/deploy/1.8+/*.yaml ./vendored/ - git add ./vendored - rm -rf sources generate: desc: generate cmds: - kr8-helpers clean-output - find vendored -type f -name *.yaml -exec kr8-helpers yaml-install '{}' \\; # install all the manifests in the vendored directory directly, without changing then # use the metrics-server-deployment.yaml as the input to the jsonnet file - KR8_JSONNET_ARGS='--ext-str-file inputMetricsServerDeploy=vendored/metrics-server-deployment.yaml' kr8-helpers jsonnet-render metrics-server-deployment.jsonnet Jsonnet You'll notice in the taskfile above that this line: KR8_JSONNET_ARGS='--ext-str-file inputMetricsServerDeploy=vendored/metrics-server-deployment.yaml' kr8-helpers jsonnet-render metrics-server-deployment.jsonnet References one of the files in vendored. This give us the ability to modify this file. Here's how the jsonnet looks: local helpers = import 'helpers.libsonnet'; local parseYaml = std.native('parseYaml'); # this must match the `ext-str-file` value in the taskfile # it imports those values with the variable name deployment local deployment = parseYaml(std.extVar('inputMetricsServerDeploy')); local args = [ --kubelet-insecure-tls , --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname , ] [ # drop all the secrets if they're found, we don't want to check them into git if object.kind == 'Secret' then {} else object for object in helpers.list( helpers.named(deployment) + { # grab kind deployment with name metrics-server, and add some more args ['Deployment/kube-system/metrics-server']+: helpers.patchContainerNamed( metrics-server , { args +: args, } ), } ) ]","title":"YAML"},{"location":"components/yaml/#yaml-component","text":"kr8 can use a static k8s manifest as a source input. You can then manipulate the structure of that YAML using Jsonnet. kr8 takes care of the heavy lifting for you.","title":"YAML Component"},{"location":"components/yaml/#taskfile","text":"You'll need a taskfile that downloads the original manifests for you in the fetch task. Here's an example: version: 2 # Download the example manifests for the metrics server. # This creates a directory, vendored which contains the manifests tasks: fetch: desc: fetch component dependencies cmds: - rm -rf vendored - mkdir -p vendored sources - git clone --depth=1 https://github.com/kubernetes-incubator/metrics-server sources/metrics-server - cp -a sources/metrics-server/deploy/1.8+/*.yaml ./vendored/ - git add ./vendored - rm -rf sources generate: desc: generate cmds: - kr8-helpers clean-output - find vendored -type f -name *.yaml -exec kr8-helpers yaml-install '{}' \\; # install all the manifests in the vendored directory directly, without changing then # use the metrics-server-deployment.yaml as the input to the jsonnet file - KR8_JSONNET_ARGS='--ext-str-file inputMetricsServerDeploy=vendored/metrics-server-deployment.yaml' kr8-helpers jsonnet-render metrics-server-deployment.jsonnet","title":"Taskfile"},{"location":"components/yaml/#jsonnet","text":"You'll notice in the taskfile above that this line: KR8_JSONNET_ARGS='--ext-str-file inputMetricsServerDeploy=vendored/metrics-server-deployment.yaml' kr8-helpers jsonnet-render metrics-server-deployment.jsonnet References one of the files in vendored. This give us the ability to modify this file. Here's how the jsonnet looks: local helpers = import 'helpers.libsonnet'; local parseYaml = std.native('parseYaml'); # this must match the `ext-str-file` value in the taskfile # it imports those values with the variable name deployment local deployment = parseYaml(std.extVar('inputMetricsServerDeploy')); local args = [ --kubelet-insecure-tls , --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname , ] [ # drop all the secrets if they're found, we don't want to check them into git if object.kind == 'Secret' then {} else object for object in helpers.list( helpers.named(deployment) + { # grab kind deployment with name metrics-server, and add some more args ['Deployment/kube-system/metrics-server']+: helpers.patchContainerNamed( metrics-server , { args +: args, } ), } ) ]","title":"Jsonnet"},{"location":"concepts/clusters/","text":"","title":"Clusters"},{"location":"concepts/components/","text":"Components A component is a deployable unit that you wish to install to multiple clusters. Your component might begin life before kr8 in one of a few ways: a Helm Chart a static YAML manifest some Jsonnet but they all have something in common - you need to deploy it to multiple clusters with slight differences in configuration. Taskfile This task file lives inside the component directory. It should contain two tasks: fetch - a manually run task which downloads all the components' dependencies (for example, helm chart or static manifest) generate - this is the task that's run when kr8 generates the manifest for the cluster These tasks will be highly dependent on the particular component - for example, a component using a helm chart will generally have a different set of fetch and generate tasks to a component using a static manifest. An example Taskfile might look like this: version: 2 vars: KR8_COMPONENT: kubemonkey tasks: fetch: desc: fetch component kubemonkey cmds: - curl -L https://github.com/asobti/kube-monkey/tarball/master kubemonkey.tar.gz # download the local helm chart from the git repo - tar --strip-components=2 -xzvf kubemonkey.tar.gz asobti-kube-monkey-{{.GIT_COMMIT}}/helm # extract it - mv kubemonkey charts # place it in a charts directory - rm -fr *.tar.gz # remove the tar.gz from the repo vars: GIT_COMMIT: sh: curl -s https://api.github.com/repos/asobti/kube-monkey/commits/master | jq .sha -r | xargs git rev-parse --short generate: desc: generate cmds: - KR8_COMPONENT={{.KR8_COMPONENT}} kr8-helpers clean-output # clean the tmp directories each time we generate - KR8_COMPONENT={{.KR8_COMPONENT}} kr8-helpers helm-render-with-patch {{.KR8_COMPONENT}} patches.jsonnet # our generate command, which in this case is a helm-render with some patches in a jsonnet file Params kr8's most useful feature is the ability to configure parameters for a specific cluster. It does that by specifying a params.jsonnet in each component. There are some required parameters which always must exist. They are: namespace : the namespace the component should be installed in release_name : analogous to a helm release - what the component should be called when it's installed into a cluster kubecfg_gc_enable : whether this component should be garbage collected when the deployer script cleans up this component (generally should be false for important system components like namespaces) Without these parameters, components will not install a function. A barebones params.jsonnet would look like this: { namespace: 'kubemonkey', release_name: 'kubemonkey', kubecfg_gc_enable: true, } Cluster specific parameters Once you start to install components into clusters, you'll want to specify parameters of your own. These are done in the params.jsonnet and you can either specify a default, or make it mandatory using jsonnet's error . Here's an more detailed example: { namespace: 'kubemonkey', release_name: 'kubemonkey', kubecfg_gc_enable: true, dry_run: false, run_hour: error 'Must specify a time for kubemonkey to run' }","title":"Components"},{"location":"concepts/components/#components","text":"A component is a deployable unit that you wish to install to multiple clusters. Your component might begin life before kr8 in one of a few ways: a Helm Chart a static YAML manifest some Jsonnet but they all have something in common - you need to deploy it to multiple clusters with slight differences in configuration.","title":"Components"},{"location":"concepts/components/#taskfile","text":"This task file lives inside the component directory. It should contain two tasks: fetch - a manually run task which downloads all the components' dependencies (for example, helm chart or static manifest) generate - this is the task that's run when kr8 generates the manifest for the cluster These tasks will be highly dependent on the particular component - for example, a component using a helm chart will generally have a different set of fetch and generate tasks to a component using a static manifest. An example Taskfile might look like this: version: 2 vars: KR8_COMPONENT: kubemonkey tasks: fetch: desc: fetch component kubemonkey cmds: - curl -L https://github.com/asobti/kube-monkey/tarball/master kubemonkey.tar.gz # download the local helm chart from the git repo - tar --strip-components=2 -xzvf kubemonkey.tar.gz asobti-kube-monkey-{{.GIT_COMMIT}}/helm # extract it - mv kubemonkey charts # place it in a charts directory - rm -fr *.tar.gz # remove the tar.gz from the repo vars: GIT_COMMIT: sh: curl -s https://api.github.com/repos/asobti/kube-monkey/commits/master | jq .sha -r | xargs git rev-parse --short generate: desc: generate cmds: - KR8_COMPONENT={{.KR8_COMPONENT}} kr8-helpers clean-output # clean the tmp directories each time we generate - KR8_COMPONENT={{.KR8_COMPONENT}} kr8-helpers helm-render-with-patch {{.KR8_COMPONENT}} patches.jsonnet # our generate command, which in this case is a helm-render with some patches in a jsonnet file","title":"Taskfile"},{"location":"concepts/components/#params","text":"kr8's most useful feature is the ability to configure parameters for a specific cluster. It does that by specifying a params.jsonnet in each component. There are some required parameters which always must exist. They are: namespace : the namespace the component should be installed in release_name : analogous to a helm release - what the component should be called when it's installed into a cluster kubecfg_gc_enable : whether this component should be garbage collected when the deployer script cleans up this component (generally should be false for important system components like namespaces) Without these parameters, components will not install a function. A barebones params.jsonnet would look like this: { namespace: 'kubemonkey', release_name: 'kubemonkey', kubecfg_gc_enable: true, }","title":"Params"},{"location":"concepts/components/#cluster-specific-parameters","text":"Once you start to install components into clusters, you'll want to specify parameters of your own. These are done in the params.jsonnet and you can either specify a default, or make it mandatory using jsonnet's error . Here's an more detailed example: { namespace: 'kubemonkey', release_name: 'kubemonkey', kubecfg_gc_enable: true, dry_run: false, run_hour: error 'Must specify a time for kubemonkey to run' }","title":"Cluster specific parameters"},{"location":"concepts/helpers/","text":"Helpers","title":"Helpers"},{"location":"concepts/helpers/#helpers","text":"","title":"Helpers"},{"location":"concepts/overview/","text":"Concepts kr8 has two main concepts you should be aware of before you get started: components clusters The relationship between components and clusters are simple: components are installed on clusters. You will have components that are installed on all clusters, and some components will only be installed on some clusters. Components can be declared multiple times within a cluster, as long as they are named distinctly. Clusters are unique and singular. They have a name which is specified via the directory structure under clusters Read more about components and clusters","title":"Overview"},{"location":"concepts/overview/#concepts","text":"kr8 has two main concepts you should be aware of before you get started: components clusters The relationship between components and clusters are simple: components are installed on clusters. You will have components that are installed on all clusters, and some components will only be installed on some clusters. Components can be declared multiple times within a cluster, as long as they are named distinctly. Clusters are unique and singular. They have a name which is specified via the directory structure under clusters Read more about components and clusters","title":"Concepts"},{"location":"installation/dependencies/","text":"Dependencies The kr8 binary has a single job: generate manifests. In order to ensure you can create components and install them, you'll need some dependencies. go-task Each component in a kr8 configuration directory must have a Taskfile . To generate the component, you'll need to install go-task. See the go-task installation instructions for more information","title":"Dependencies"},{"location":"installation/dependencies/#dependencies","text":"The kr8 binary has a single job: generate manifests. In order to ensure you can create components and install them, you'll need some dependencies.","title":"Dependencies"},{"location":"installation/dependencies/#go-task","text":"Each component in a kr8 configuration directory must have a Taskfile . To generate the component, you'll need to install go-task. See the go-task installation instructions for more information","title":"go-task"},{"location":"installation/linux/","text":"Linux kr8 is a Go binary, which means you can simply download it from the Github releases page RPM and DEB packages are also generated for each release Dependencies Installation with Linux does not pull in the additional dependencies. Please see the dependencies page for more details.","title":"Linux"},{"location":"installation/linux/#linux","text":"kr8 is a Go binary, which means you can simply download it from the Github releases page RPM and DEB packages are also generated for each release","title":"Linux"},{"location":"installation/linux/#dependencies","text":"Installation with Linux does not pull in the additional dependencies. Please see the dependencies page for more details.","title":"Dependencies"},{"location":"installation/osx/","text":"OS X Homebrew The easiest way to get started with kr8 is to use the homebrew tap. This will install all the tools kr8 depends on for you. brew tap apptio/tap brew install kr8 Manually kr8 is a Go binary, which means you can simply download it from the Github releases page If you choose to install kr8 manually, you'll need to install the dependencies. Please see the dependencies page for more details","title":"OSX"},{"location":"installation/osx/#os-x","text":"","title":"OS X"},{"location":"installation/osx/#homebrew","text":"The easiest way to get started with kr8 is to use the homebrew tap. This will install all the tools kr8 depends on for you. brew tap apptio/tap brew install kr8","title":"Homebrew"},{"location":"installation/osx/#manually","text":"kr8 is a Go binary, which means you can simply download it from the Github releases page If you choose to install kr8 manually, you'll need to install the dependencies. Please see the dependencies page for more details","title":"Manually"}]}